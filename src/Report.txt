编译原理课程设计
  实验报告

0. Overview
       这次课程设计主要是尝试完成 tiger 语言(一种简易的教学用语言)的编译器,
   整个编译器的结构如下图:
       实际上,不如将编译器的实现的阶段划分为 3 段,为检查、中间代码与一部分
   优化、目标代码生成,检查段有词法分析(1)            、语法分析及 syntax tree(2)
                                                        、语义
   分析(3)   。
1. Lexical Analysis
       第一个任务即是词法分析了,词法分析目的很明确,就是把源程序分为编译器
   识别的一个一个的 token,然后提供给之后的语法分析器。
       这一部分使用到了 JFlex 这个工具,     它可以根据提供的词法规定文件来自动生成
   词法分析器,     这里 JFlex 可以产生一个 java 文件,其中包含根据规定文件而有着词法
   分析功能的 scanner 类。这里,JFlex 提供了合适与之后要使用的 java cup 的接口,
   因此,在文件中加入%cup 即可。
       这一部分的主要任务即是 JFlex 输入文件(词法规定文件)的完成,其中主要的
   问题是字符串以及注释的处理。
   1.1 注释
       对于注释,处理方式即是加入一个 YYCOMMENT 状态,在 YYINITIAL 状态中,每
   当遇到\*则进入 YYCOMMENT 状态,同时在类中还应该加入对于注释嵌套深度的记
   录,即每次进入一层注释即将技术之加一。在 YYCOMMENT 状态中,忽视所有非/*
   或是*/的字符   (碰到/*需要将计数值加一,      */则减一),当计数值为 0 时, 返回 YYINITIAL
   状态。遇到 EOF 时,需要检查状态(之后会提到)          。
1.2 字符串
     对于字符串,同样给一个状态 YYSTR,在 YYINITIAL 状态中,每当遇到”则进入
YYSTR 状态,
        在类中有一个 private 的 StringBuffer 用于收集字符串。在 YYSTR 状态中,
还需要处理转义字符、转行控制,对于”...\ddd...”形式的转义字符,还需要检查这三
位数是否在范围之内,否则发生错误(错误处理之后会提到)                 。同时,还要处理特殊
的忽略转行的形式,另外,虽然 tiger manual 中好像并未提到,但是这里规定如果
没有忽略转行,任何的字符串中的转行都是非法的。最后,YYSTR 状态下,如果遇
到没有 escape 的”,则返回 YYINITIAL 并同时返回收集的字符串。
1.3 其他
     其他的 token 还有关键字、特殊符号、ID、数字,这些都比较好写。
1.4 EOF
     当遇到 EOF 时, 还需要做特殊的检查,      即如果没有处于 YYINITIAL 的状态的话,
则发生错误。
1.5 错误处理
     这一部分的错误处理比较简单,仅仅是扔掉发生错误的字符集合即可,同时还
要将错误收集于调用词法分析器时传入的 tiger.errors.ErrorList 类中,  以便于之后的报
错,这一部分发生错误后仍可继续之后的语法分析。
2. Syntax Analysis
        语法分析部分同样是使用自动生成工具,这里使用的是 java cup 语法生成器,
   因此这一部分需要完成 java cup 的规定文件,同时,由于要生成语法树,因此还要
   为语法树建立相应的数据结构。
   2.1 语法检测
        根据 tiger manual 中的语法说明写出相应的规则,    主要位于 tiger.cup 文件之中,
   整个程序都是 Expression,     因此开始非终结符号定为 expr。  Manual 中的 expr 共有 17
   种形式,其中 lvalue 还有 3 种形式,其实大体上来说,在这里的定义都差不多,都
   是按照 cup 的语法来写,这里举一个例子。
        比如对于表达式 expr:lvalue := expr 这条赋值语句来说:
   产生式右端的符号后加上冒号以及变量表示该符号所带有的值(在 cup 文件的前面
   有声明)   ,而之后的{:与:}之间的 java 语句则是该产生式约归时将会执行的动作,
   而 RESULT 则是约归时将会赋予产生式左端的非终结符号的值。
   2.2 避免语法冲突
        这一部分很重要的一点即是避免语法冲突,比如对于表达式 expr:expr op expr
   来说,如果要避免冲突,那么必须要改变产生时的形式,好在 cup 提供了关于优先
   级以及左右结合的声明,这样就无需繁琐地修改产生式了。
        这里,优先级最高的是单元符号取负,之后是左括号(用于改变优先级)                     ,
                                                             (左
   括号与单负号应该不会冲突,           因此二者优先级应该没关系)     ,之后是常规的运算符号,
   在之后是比较符号(不能左结合或是右结合)               ,之后分别是与、或、赋值;最后,规
   定 else 的优先级比 then 高,这样可以解决 dangling else 的问题。
      另外,这一部分还遇到了一个问题,那就是按照 manual 上的语法规定,好像
有一个 reduce/shift 冲突无法解决:
      即是 expr:type-id [expr] of expr 与 lvalue: id,由于词法分析部分无法区分
type-id 以及其他的 id,当 shift 过一个 id 后再遇到[符号时会有按第一条产生式 shift
以及约归为 lvalue 的冲突。
      这里采用的方法是修改语法,将 expr:type-id [expr] of expr 修改为 expr:lvalue
[expr] of expr,然后在该产生式约归的时候判断该 lvalue 是否是单独的 id 组成的
lvalue,不是的话则报错。
2.3 错误处理
      这一部分的错误处理同样是传入一个 tiger.errors.ErrorList,但是由于比较麻烦,
就没有做 error recovery,即是发现语法错误则将错误加入 ErrorList,之后直接抛出
异常而结束语法分析。当然这样的做法可能不太好,但是一来 error recovery 确实比
较麻烦,二来如果有语法错误的话,很多时候这样的错误已经是 fatal 的了,之后的
分析可能就不准确了。
2.4 symbol 的处理
      这里 symbol,即 id 的处理是按照模板上来的,即是定义 Zsymbol 类(类中有一
个 HashMap 来存放 Zsymbol 与 String 的对应关系)         ,这样也许速度快一些。
   2.5 语法树的构建
        语法树的构建主要还是在 cup 声明文件之中完成的,而这里很重要的即是定义
   一大堆的语法树的组件,这里其实和模板上的差不多,只不过给各个类换了一些顺
   眼的名字,抽象类 Zposition 中用两个变量(line , column)来存放位置,另外还有一些
   修改。
        主要的类即是表示 expr 的抽象类 Expr,而每一条产生式即对应了 Expr 的一个
   子类,模板中没有单负号表达式的类,因此加入了 Expr_neg。另外,对于所有的表
   示 list 或是 sequence 的类中,都采用了 java 库函数中的 List 来存放,而不是像模板
   中那样类似于链表式的存放。
   2.6 测试与 print
        测试类中调用了 cup 的产生的 parser 类的 parse 函数,之后检查异常(异常为
   语法分析错误时抛出的)         ,最后打印错误或是 Expr 的信息。
        这里采用的是模板中的 Print 类,来打印相关的 Expr 的信息,实际上即是采用
   分派方式,用 instanceof 关键字来判断 Expr 具体的类的信息,之后用 downcast 转换
   后打印信息。
3. Semantic Analysis
        语义检查应该是对于程序的编译器的检查的最后一部分,当程序语法符合要求
之后,其语义可能会与语言的要求有所区别。语义分析的最主要的工作即是类型检
查,tiger 语言应该是强类型的语言,且是静态类型的,在编译阶段则需要解决所有
的类型问题。不得不说,这一部分的任务的确很多,由于 tiger 还支持类型的声明以
及类型的重命名(类似于 C 中的 typedef)       ,类型检查很是麻烦。
     实际上,在具体实现上,类型检查是通过语法分析所产生的语法树的数据结构
来进行的,主要是通过函数 type_check 来进行的。
     这个函数的参数有类型声明的 symbol table,变量以及函数(它们共用一个名
字空间)的 symbol table,布尔型的 in_loop 表示是否位于循环之中(用于检查 break
语句是否合法)        ,以及错误列表。其返回值为该表达式的类型。
3.1 Symbol Table
     Symbol Table 也许是这一部分最重要的数据结构,这里用的是 Table 泛型类,位
于 tiger.symbol 这个 package 中,它的实现类似与官方模板中的 Table 类。每个 Table
包含一个当前 scope 的映射的 Map(采用的是 java.util 中的 HashMap)     ,同时还有上
一层 Table 的 reference。
     这样 Table 就相当于一个 Map 的栈,beginScope()与 endScope()相当于对栈进行
push 与 pop 的操作,    而 put()将映射放于当前的 Map 中,get()则从当前 Map 沿着 Table
链往回寻找,没有找到则返回 null。
3.2 类型
     类型即是表示一个表达式的类型,这里类型类放在 tiger.typing 中,主要类型用
的是官方模板中的类型,有 ARRAY、INT、NAME、NIL、RECORD、STRING、VOID,
另外,还加入了 TO_FILL(用于处理类型声明,之后会提到)               ,以及 ERROR_STATE(用
于处理错误)       。
     每个类都有 actual 与 coerceTo 函数,前者主要是针对 NAME 型的类,即类型变
量所绑定的类型,后者用于检查两个类型是否一致。
3.3 错误处理
     错误处理与之前一样,都是将错误加入 ErrorList 之中,而对于返回值,这里即
是返回其所期望的结果,即如果发生错误,记录下错误,然后按照不发生错误的情
况返回从而继续处理。当然,有的时候,无法知道当前的应该的类型,这时候,用
类型 ERROR_STATE 代替,其特征是忽视与其他类型的 coerceTo 测试。
     在之后的实现之中,由于没有考虑周全,许多对于类型的检测都采用了
instanceof 的方法,而不是 Type 的 coerceTo 函数,因此有些情况下 ERROR_STATE 的
作用并没有体现,这是此部分的一个疏漏(之后会再提)                ,但应该影响不会很大。
3.4 一般的类型检查
     前面提到过,整个类型检查是通过 type_check 的函数调用而驱动的,然后,函
数会按照语法树递归地来进行类型检查(即语义分析,实际上大部分的语义分析都
包含在类型检查之中)          。如同语法分析,每个 Expr 都有其相应的针对其语法结构的
类型检查,这里举 if_else 的例子,特殊的之后会再提。
     这里,   首先检查的是 if 之后的 expr 的类型,  先对其(e1)进行递归调用 type_check
得到其类型,之后判断其是否是 INT 类型(之前提到过,这里用 Type 的 coerceTo 函
数可能会更好)       ,并作相应处理;之后同样得到 e2 的类型,并判断是否为 VOID(按
照 manual,if_then 语句只能返回 VOID)  ;最后无论是否发生错误,都按照预期的正
确结果返回。
3.5 Expr_let 以及 声明语句
     Expr_let,即 let 语句,是十分特殊的一种语句,所有的类型变量声明、函数声
明以及大部分的变量声明都位于 let 语句中,因此其实现十分特殊。
     (1) 作用域
     首先要做的,即是为 let 语句开辟新的作用域,这里对 t_env(类型变量)以及
v_env(函数以及普通变量)调用 beginScope 函数即可。
     (2) 处理声明
     这一部分是最麻烦的,tiger 的声明一共有三种:普通变量声明、函数声明以及
类型声明。这三种变量的处理方式有很大不同,因此从声明列表中每取出一个声明
都要判断其类型以作相应处理。
     (3) 普通变量声明
     普通变量声明的处理最为简单,因为按照 manual,普通变量的作用域从当前声
明语句开始,       因此不用考虑之后的变量对其的影响,        直接调用普通声明的 type_check
函数即可,之后将其放入 v_env 中。
  对于普通变量的 typecheck 也比较简单,主要是比较其定义表达式的类型以及
其声明类型是否一致,声明类型可以省略(这是其类型由表达式决定)                  。这里的主要
可能发生的错误有声明与定义类型不同、声明类型未定义、以及将 NIL 赋给省略了
声明类型的普通变量。
  (4) 函数声明
  函数声明比较复杂,由于可以进行函数间相互调用,函数的作用域开始于一连
串函数声明(必须相连,不能被其他定义分开)的开始,因此后面定义的函数可以
用于之前的函数。因此,函数声明的处理则必须以函数声明的连续序列来处理。
  实际上,在语法分析时,就可以将连续的函数声明放在一起,但是由于当时没
有考虑到函数声明需要特殊处理,因此,在函数声明的语义分析中,第一步做的既
是这一工作。
  当然,由于函数声明的函数原型是独立的,因此,函数声明的处理分为两步,
可以先分别获得函数原型,放入 v_env 之中,之后再处理函数体(这时已经知道应
该有的函数声明的原型)     。这里调用的是 type_get 与 type_check 函数,前者获得函
数原型,后者检查函数体的类型。
  函数体的类型检查没什么特殊的地方,只要最后和之前得到的函数原型的返回
值类型比较即可;而函数原型则需要分别检查函数声明的参数列表和返回值,然后
存在函数声明 Dec_fun 中(Dec_fun 中有两个特殊的 field:return_type 与 arg_type
以存放其原型)  。
  (5) 类型声明
  类型声明的检查是最为复杂的,这里总共分了四步。
  类型声明与函数声明一样,同样是以连续的类型声明语句为单位,因此之前同
样要将相邻的类型声明放在一起进行检查。
  首先,将所有的类型变量设定为 TO_FILL 的类型,并放入 t_env 之中,实际上,
即是表示该类型变量是被声明过的,而之后的处理会覆盖 TO_FILL。
  之后,  分别对各个声明语句进行 type_check 函数调用,     处理其类型。     这一步中,
获得的类型并不完整,应为其中可能会存在 TO_FILL 类型,实际上,根据实际的声
明语句的处理,获得的类型中会存在含有 TO_FILL 类型的 binding 的 NAME 类型。单
独的类型声明语句又可以分为三种:record、array、type-id。这三种的处理其实并不
复杂,因为根据 manual,这些类型只能有 type-id 构成,因此嵌套不会继续下去,
实际上所有的 type-id 都新建一个 NAME 型的类型,然后在 t_env 中找到相应的实际
类型(可能是 TO_FILL)binding 到这个 NAME 类型即可。
  之后,则需要处理 TO_FILL 类型,完成第二步之后,所有的应该完成的类型声
明已经存在于 t_env 之中了,只不过其中一些还并不完整。因此,再次遍历这些声
明语句,找到其中 binding 到了 TO_FILL 的 NAME 类型,用新的类型(在 t_nev 中查
   找)   代替即可,       实际上,    这一部分应该是对于指针的操作     (相对于 C 而言)  ,由于 java
   中所有的对象都是引用,因此也就相当于指针操作。
         最后,根据 manual,还需要一步操作,就是查找是否有循环的类型声明,这时
   还需要遍历一遍这些声明,使用官方模板的 NAME 的 isloop()进行检查即可。
         当然,由于类型的声明的确比较复杂,因此可能会存在许多的问题,按照正常
   情况下(通过官方给的 testcase)来说这四步问题不大。
         (6) let 的 expr-seq
         处理了声明之后,处理 let 的语句就简单很多,只需要一次遍历即可,不过,
   需要注意的是最后还需要离开作用域,及调用 endScope 函数。
   3.6 for 语句的 index 声明
         几乎所有的声明语句都存在与 let 语句中,          唯一的例外好像就是 for 语句的 index
   变量的声明,当然,由于是一个整型的声明,只需要在 for 语句的处理的开始进行
   类型检查并加入到 env 之中即可。
         在这里,manual 中还提到在 for 语句之内,index 变量是不能被赋值的,这一点
   在程序中并未实现(一开始并未注意)               ,但应该影响不大(之后会再提到)         。
   3.7 break 语句的检查
         貌似整个语义分析中与类型关系不太大的就是 break 的检查,因此也就在
   type_check 之中一并完成了,        主要是通过参数 in_loop 来完成,
                                                 但遇到 break 语句时,
   in_loop 如果为假,则报错即可。
   3.8 总结
         语义分析这一部分的确比之前的词法分析、语法分析都要复杂很多,其中,最
   为主要的问题就是声明语句的处理,               作者测试了官方所给的几十个 testcase,     在语义
   分析这一块应该都没有问题,              然而这里有一些例外以及疏漏     (的确是发现得太晚了,
   更正的话比较麻烦,可能会影响整体结构)               :(1)之前提到过的 instanceof 与 coerceTo
   的问题,       导致一个错误可能引发几条报错。        (2) 同样是之前提到过的 for 语句的 index
   赋值的问题(实际上许多语言都允许这样赋值)                 ,这里的与 manual 的不一致影响不
   会太大。(3) manual 中提到 record 的变量定义应该按照声明的 field 的顺序进行并且
   不能有漏掉的 field,而由于实现上使用了 Map 来表示 record,因此也就没有这样的
   限制,同样影响不会很大。(4)代码写的有些乱,可能还有其他尚未发现的问题。
4. Intermediate Code
         经过语义分析之后,程序就被编译器认为是正确的,于是开始从高层的语言转
   化为低层次的语言;             再转化为机器的语言之前,    一般在这之间要先转化为中间代码。
   经过语法分析,得到了语法树,经过语义分析,得到了语法树的节点的一些信息;
而中间代码的生成即是遍历语法树而达到的。
      在这一部分,就要考虑很多问题了,最重要的是中间代码的选择,中间代码既
要易于从高级语言转换而来,又要易于转化为底层的机器语言;同时还要考虑中间
代码需要带有的高级语言中的信息如何存储。书上采用的方式是用树状结构表示中
间代码,而这里采用的是类似于三地址代码的方式来表是中间代码(加入许多临时
变量)   。
4.1 中间代码的表示
      这里采用的是类似于三地址代码的方式,详见 tiger.ic 这个 package,其中包括
IcStmt、  IcFun 以及 IcOper。IcStmt 表示中间代码中的表达式,        它本身是一个抽象类,
他有许多 IcStmt_*这样的子类,表达具体的表达式(很类似于机器代码中的语句)                               ;
IcFun 代表一个函数,它含有 IcStmt 的列表,同时还可能存有嵌套函数;IcOper 代表
左值或是右值,其子类 IcConst 代表常量,IcVar 为变量。
      另外,在 tiger.ic.IcFun 中,还有 static 的 global_fun 以及 main_fun,global_fun
代表整个 global 环境,它并不是正真的函数,他的作用是包含库函数;main_fun 类
似于 C 中的 main 函数,是程序的入口函数,其实现就是将之前得到的程序的 Expr
进行翻译后加入此函数中。
4.2 中间代码的产生
      中间代码的产生过程类似于类型检查,同样是遍历语法树(实际上,可以在类
型检查的同时完成中间代码产生,但为了简洁易于编写还是分开了)                             ,这里调用的是
ic_trans 函数,函数的参数是当前的函数,以及 break 的去处(用于 break 语句的处
理)  , 其返回两个值,       即是产生的中间代码的列表        (这里用的是 java.util 的 LinkedList)
以及可能的求得的值。为了能在一个函数返回两个值,这里用的是 Object 的 array
来保存。
      和类型检查一样,ic_trans 函数对于不同的表达式需要不同的处理。这里列出
几个特殊的处理。
4.3 let 语句的处理
      同样,let 语句在中间代码产生的时候也是十分难处理的,首先处理 let 中声明
的变量和函数,        这里可以忽略类型声明, 因为类型检查之后其实不需要类型声明了。
这里分为两步,首先将所有的声明加入到当前 IcFun 的变量表以及函数表当中;之
后处理变量的初始化以及函数的函数体,再分别将获得的中间代码加入到代码列表
之中。之后,再处理 let 语句的表达式,这里和 Seq 语句的处理方式相同。
4.4 有关控制语句的处理
      许多语句会产生控制语句(这里是 IcStmt_branch)  ,比如 while、for、if 以及二
元操作符与和或,这里的处理就是要添加标号。这里,将一个标号也设置为一条中
间代码语句(这样比较易于实现)         ,结合 branch 以及标号的添加即可以翻译各种含
有控制语句的表达式。
      这里以 while 语句为例,它使用两个标号,一个用于循环,一个用于循环的退
出,while 的循环体之后加入一条 goto 语句返回循环判断部分。
      二元操作符中的逻辑与和逻辑或同样需要控制语句,因为 manual 中提到它们
都是短路求值的,因此在知道最终结果时不应该继续求值。
4.5 array 和 record
      array 的情况比较特殊,因为它其实是类似于 C 中的 malloc,是动态获取空间的,
因此在编译时不能为它分配空间,这里在中间代码中加入了 IcStmt_new 语句,用于
动态申请空间       (这样的语句应该可以用调用特殊函数实现)      ,同时用一个循环为 array
赋值;这里忽略不合法的 array 申请(size<=0,这种情况交给系统调用处理)           。
     record 的处理比 array 要简单,因为在编译时已经知道它的空间要求(这里的
record 不像 C 中的 struct,它其实是引用的集合或是指针的集合)         。
4.6 函数调用的处理
     函数的调用主要是翻译为 IcStmt_call 或是 IcStmt_callback,前者为过程调用,
并不返回,可能这样的划分并不需要(比如可以将返回值存在特殊的寄存器之中)                    ,
但是这里还是尽量不考虑具体的机器代码或是汇编代码的实现。而在之前,首先要
求出所用的参数的值,之后在进行调用。
4.7 break 语句
     对于 break 语句,只需要一条 goto 语句即可,而 goto 的目标即是 ic_trans 函数
的第二个参数。
4.8 库函数
     对于库函数,应该做一些特殊处理,所有的库函数位于 tiger.builtin 之中,其实
这里的处理也比较简单,即是在 IcFun 中加入一个 boolean 型的 is_builtin,对于所有
的库函数,将它们的 is_builtin 设置为 true 即可,遇到之后在做特殊处理,库函数应
该在之后会提前编译成机器代码。
4.9 小结
     中间代码这一部分的确比较纠结,这里采用的是三地址代码的方式,但是初步
的实现之中是忽略掉了语法树之中的一些信息的,其中最重要的就是变量和函数的
作用域,这里为了中间代码的简洁直观,并没有将中间代码设计为含有作用域的层
次结构(中间代码的唯一的层次结构是函数的嵌套结构)               。实际上,作用域的作用也
许就是用于翻译为汇编代码时的临时变量的分配,当一个变量离开其作用域时,也
就不需要保存它的值了。
     由于 tiger 语言允许函数之中声明函数,    那么变量的作用域就更加复杂,         同时之
后还需要为函数设定 access link,   因此在中间代码阶段以简单为主,         忽略了一些信息,
(这样产生的代码可能会浪费一些空间)          。不过,其实如果再次遍历语法树,应该还
是可以将信息再补上的,这个如果之后有时间的话会考虑一下。
5. Block
       得到中间代码之后,下一步做的即是对于中间代码的分析,这些分析很多是为
   最终的代码生成而准备的,而如果要做优化的话,一般也是从中间代码入手。对于
   中间代码,很重要的一部即是程序分块以及获得程序流图,在一个程序块中,所有
   的语句都是顺序执行的,而块与块之间可能有关联(有跳转语句而来)            。这里,对于
   程序块的处理位于 tiger.block 之中,其中 Block 类表示一个程序块。
       Block 类有许多部分组成,   基本部分有中间代码的列表、    所属的函数以及函数中
   的标号;另外,还有与其他 Block 的连接关系;之后还有用于 liveness analysis 的相
   关数据。
       Block 的处理主要分为四步。
       第一步是合并相邻的 label,这一步的原因主要是中间代码将 label 也看做是一
   个语句,因此可能会存在相邻的 label,这一步只需要遍历一遍中间代码列表即可。
       第二部是分块,这一步最为关键,实际上仍然是遍历中间代码,找到所有的跳
   转语句(jump 与 branch)以及 label 语句,以它们作为分块的标号进行划分,而划
   分的同时还要保存下一个块的地址(用中间代码语句的序号表示,因为这个时候下
   一个块可能还未生成)     ;之后遍历一遍所生成的所有块,       根据之前的序号将块连接起
   来。
       第三步是存活分析,使用书上的数据流方程不断地循环求解即可;首先遍历所
   有的块,获得程序块的 use、def 的变量的列表,之后迭代求解数据流方程得到每个
   块的 in、out。
       第四步是针对每个块中语句的下次引用分析,这对于之后的寄存器分配可能会
   有帮助。   (实际上,之后并没有用到这个信息)
6. Register Allocation
         寄存器分配是从中间代码到汇编代码的很重要的一步,中间代码假设的是有无
   穷多的临时变量,而实际的机器的寄存器是有限的,因此可能会发生寄存器不够用
   的情况,而最终的汇编代码的效率与寄存器分配的效率有很大关系。
         理论课的教材中提到了一些简单的寄存器分配的方法,一个就是在程序块之中
   利用之前求得的下次引用信息来进行寄存器分配,但是这种分配不是全局的,可能
   要在程序块的最后在内存中保存仍然存活的变量,而在另一程序块中要用到这个变
   量还需要从内存中再提取,而很多时候并不需要这样。
         而还有一种简单的方法即是利用 graph coloring,对于每个函数产生对应的
   register-interference graph,从而利用染色的方法来分配寄存器。虽然说实话,最终
   实行起来感觉这种方法的好处并没有在这次课程设计中完全体现(代码生成部分会
   再提到,tiger 语言允许函数嵌套,那么所有的 local 变量也许必须在内存中有相应的
   存储空间,同时还需即是更新以解决不同步的问题)               ,最终选择了这一方案。
         染色的方案实行起来还需要一些处理,需要在之前的程序块的存活分析的基础
   上进一步获得每条中间代码语句的存活的变量的信息,同样是对每个程序块遍历一
   遍即可。之后,对于每个函数,用图的数据结构保存变量的信息,图的顶点代表变
   量,边代表变量之间有关联(不能染为同一颜色,即不能同时赋予同一个寄存器)                     ,
   之后,寄存器的分配问题即是无向图的染色问题。实际上,这个问题很难解决,这
   里用的也就是最常用的方法,不断地剔除度数小于 k(寄存器总个数)的顶点放到
   栈中,如果没有则选择一个顶点(这个点的选择有许多方法,这里采用的是一种简
   单的、选取度数最大的顶点的方法)               ;当所有顶点都入栈之后再从栈中返回,当某个
   顶点无法染色时,则标记为 spilled。
         最终,这一部分产生的许多信息都存在函数 IcFun 类之中。
         其中最终要的就是所得到的寄存器分配的结果,            这里用一个 HashMap 表示。实
   际上最初这一部分犯了很大的一个错误,               当时将寄存器的信息存放于 IcVar 即是特定
   的变量之中,最后到代码生成才发现由于具体实现中,每个函数存放的都是 IcVar
   的引用,因此一个变量在不同函数之中的寄存器分配情况可能不同(tiger 中的嵌套
   函数即是允许了这一点,若是 C 语言中除了全局变量则不会出现这样的问题,代码
   生成部分会仔细说明这个问题)               。
7. Code Generation
        代码生成这一部分应该是最为麻烦的,同时也是 debug 最难的一部分,因为这
   一部分其实是对于中间代码生成之后的所有工作的检测(说实话,Block 和 Register
   Allocation 的测试应该都对到这一部分了,    光用眼睛看近似于汇编层次的代码是很难
   查出错误的)       ,因此这一部分应该是成败在此一举了。
   7.1 函数中的函数
        之前提到很多次 tiger 语言中(貌似很多语言都支持之一特性)的嵌套函数,即
   可以在函数中定义函数,          之前总是觉得嵌套函数没什么特别的,   到了实际生成代码,
   才发现它很特殊。最大的特点即是嵌套的函数可以引用以及修改上层的函数的局部
   变量,这样的话函数的局部变量有很多都必须保存在栈中,这一点对于寄存器分配
   也有影响。首先,局部变量不能设置为像 C 中的全局变量,因为函数可以不断被调
   用;同时,也不能只分配到寄存器中,因为可能被嵌套的函数使用;因此,保存在
   栈中是最好的选择(也正是由于这一点,函数的参数也存于栈中,而不是 Mips 提供
   的$a0,$a1...中)   。
        实际上,一种方案是不为局部变量以及参数分配寄存器,只为临时变量分配寄
   存器,那么每次使用局部变量的时候都要从内存中提取,这样可能效率不高;而这
   里再分配寄存器的没有区分局部变量和临时变量,后来就发现了同步的问题:如果
   局部变量分配到了寄存器,那么寄存器就相当于局部变量的 Cache,当对这个局部
   变量进行修改的时候应该要将值存回内存中(若是其它函数引用这个变量,应该获
   得更新值)      ,这里采用的是最简单的方法,    即是每次修改都就将局部变量的值存回内
   存中;另外还有一个问题,就是假如调用的函数改变了局部变量,那么应该从内存
   中重新提取这个值,这里采用的也是最简单的方法,就是每次调用函数之后,对所
   有寄存器,如果其代表局部变量,则重新从内存中提取值。
        到头来很尴尬地发现为局部变量分配寄存器的意义好像并不是很大,很多时候
   还是要从内存中获取最新值,          这样貌似还浪费了寄存器(可以赋给临时变量)           。当然,
   个人认为这样还是有意义的,因为当只是引用局部变量的时候,就不必再去找内存
   了;而解决这一问题的方法可能就是要进行函数间的分析,应该要分析每个函数具
   体引用、修改了哪些值,同时还有其中调用的函数引用、修改了哪些值,这里又牵
   涉到递归以及相互调用的问题,分析起来估计很是复杂,这里就没有进行函数间的
   分析,而是采用简单的但是效率较低的方案。
   7.2 栈的分配
        Frame layout 应该是代码生成的核心问题,一个 frame 或是 activation record 代
   表的是一层函数的调用的情况,由于之前提到过的嵌套函数的关系,这里 frame 的
   设置也比较复杂,可能也并不高效。实际上可以把 frame 分解为两个部分,一部分
   有 caller 负责,而另一部分由 callee 负责,中间的分界线即是 frame pointer($fp)     。
   同时这样的分配有一些针对于最终的 Mips 代码,       可能并不是非常通用       (比如有 Mips
中的返回寄存器$ra,一些实现将返回地址放在栈中)                     。
      图中的分配的顺序是从上到下的,这里的栈采用的是从高地址往低地址,上层
的是 caller 负责的部分      (具体实现位于 IcStmt_call 的 gen_mips 中)   , 从上到下依次是
caller-save 的寄存器、实际参数、caller 的返回地址(不是 callee 的,实际上同样是
应该算是 caller-save 寄存器)   、callee 的 access link(被调用函数的在 tiger 代码中的
上层函数的 frame pointer,用于访问上层函数的变量)               、caller 的 frame pointer(同
样可以看做 caller-save 的寄存器)    。依次存储好这些之后,将$fp 置为储存$fp 的位置
作为被调用函数的 frame pointer,    将栈指针至于$fp-4 的位置,         之后 jal(jump and link)
                                                                        ,
之后的工作就交给 callee 负责。
      对于 callee 来说,同样在执行其语句之前需要做一些准备工作(具体实现位于
Cg_fcode_mips 函数中,代码存在每个 IcFun 中)         。首先储存 callee-save 的寄存器,之
后根据函数的局部变量、参数、引用的外部的变量、spill 的临时变量来为它们分配
空间,之前也提到过,这里用的方法比较简单,所有的局部变量都在栈中分配了空
间,所有的外部的变量也都分配好空间(不过这些空间储存的不是值,而是外部变
量的地址,这些地址在函数一开始就根据 access link 获得,以便于之后的访问以及
存储)    。同时,还计算好了每一部分的相对于$sp 的位移,以便于之后的访问时的计
算。
7.3 代码生成
      最后,对于每个 IcStmt,都有相应的 gen_mips 函数来生成 Mips 代码,对于常
数,这里采用了一种比较简便的策略,就是对于字符串常量使用 la(load address)
指令,对于整数常量使用 li(load integer)指令,这样所有的 IcOper(包含 IcVar 以
及 IcConst)的寄存器的获取都可以用一个函数来完成。
      而语句执行完之后,对于局部变量或是外部变量或是没有寄存器的临时变量,
都需要将它们写回,同样由一个函数完成。
      具体的每种语句的翻译其实都很接近于中间代码语句的意思,实际上,三地址
代码已经很接近与汇编代码了,这里的翻译都比较直观(除了之前提到过的函数调
用的翻译)       。
7.4 库函数
      tiger 的 manual 中还提到了一些库函数,这里就直接用 Mips 写出汇编代码了,
当然其中许多用的是 spim 提供的 syscall,         若是不直接用汇编写         (比如说 print 函数)
   恐怕很难实现。这里还增加了一个 cpmstr 函数,用于字符串的比较(其用法类似于
   C 中的 strcmp 函数)。
8. Summary
       最后,在 tiger.compiler 中将之前的部分整合起来(实际上就是让程序将之前的
   各个部分顺序地完成)       ,同时加入了一些命令行的选项,当然,这些就无关紧要了,
   不过也算作为整个课程设计的 putting together。
       虽然,最终的结果通过了测试程序,但感觉整个工程写的还是比较凌乱的,因
   此 bug 肯定存在;同时,在后端的代码生成部分,采用的是一些比较简单的方法,
   没有深入分析程序的结构;当然,这还不能说是一个完整的编译器,因为缺少了编
   译器中最大的一个部分优化,代码无关的优化应该是位于 Block 之后,即是对于中
   间代码的分析,作相应的局部优化、全局优化(实际上 liveness analysis 可以看做全
   局优化的一部分,但是这里其作用是为了分配寄存器)           、函数间的优化,但是,个人
   认为每一项优化的工作量可能就相当于前段所有的分析或是后端的代码生成(感觉
   上可能会很麻烦)     ,因此就没有实现。
       虽然有各种问题,但最终完成了这个课程设计还是收获很多,明白了一些光从
   理论课中无法得到的知识。
